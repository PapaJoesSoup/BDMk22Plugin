//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

using UnityEngine;
namespace BDMk22Plugin
{
	public class Mk22HUD : InternalModule
	{
		public static List<Mk22HUD> mk22HUDs;


		//ladder
		[KSPField]
		public string ladderMeshName;
		[KSPField]
		public Vector3 initialLadderOffset = Vector3.zero;
		UVTransformer ladderUVT;
		//Vector2 ladderTextureSize;

		//velocityruler
		[KSPField]
		public string velRulerMeshName;
		[KSPField]
		public float velRulerCoefficient = 1.134842857f;
		UVTransformer velRulerUVT;
	
		//altruler
		[KSPField]
		public string altRulerMeshName;
		[KSPField]
		public float altRulerCoefficient = 1;
		UVTransformer altRulerUVT;
		[KSPField]
		public float maxRadarAlt = 5000;
		[KSPField]
		public string aslMeshName;
		[KSPField]
		public string rdrMeshName;
		GameObject aslObject;
		GameObject rdrObject;

		//horizAoA
		[KSPField]
		public float horizAoACoefficient = 90;
		[KSPField]
		public float horizAoALimit;

		//vectorIndicator
		[KSPField]
		public string velVectorObjectName;
		[KSPField]
		public float velVectorVertCoefficient;
		[KSPField]
		public float velVectorHorizCoefficient;
		[KSPField]
		public float velVectorTopLimit;
		[KSPField]
		public float velVectorBottomLimit;
		[KSPField]
		public float velVectorHorizLimit;
		GameObject velVectorObject;
		Vector3 velVectorOrigPos;

		//digital
		[KSPField]
		public string digitReferenceName;
		GameObject digitReference;
		[KSPField]
		public string altDigitalTransformName;
		[KSPField]
		public string spdDigitalTransformName;
		Transform altDigitalTransform;
		Transform spdDigitalTransform;
		HUDNumberField altNumberField;
		HUDNumberField spdNumberField;
		[KSPField]
		public float digitCharWidth = 0.1598097f;
		[KSPField]
		public float digitPixelWidth = 16;
		[KSPField]
		public float digitScale = 0.01848428f;

		//warnings
		[KSPField]
		public float warningBlinkRate = 5;
		[KSPField]
		public string stallMeshName;
		[KSPField]
		public float stallAngle = 30;
		[KSPField]
		public string slipMeshName;
		[KSPField]
		public float slipAngle = 15;
		GameObject stallObject;
		GameObject slipObject;

		//headingruler
		[KSPField]
		public string headingRulerMeshName;
		UVTransformer headingRulerUVT;

		//overlay
		[KSPField]
		public string overlayMeshName;
		Transform overlayTransform;

		//startup screen
		[KSPField]
		public string logoMeshName;
		[KSPField]
		public string subLogoMeshName;
		[KSPField]
		public string loadContainerName;
		[KSPField]
		public string loadBarName;
		Transform logoTransform;
		Transform subLogoTransform;
		Transform loadContainerTransform;
		Transform loadBarTransform;

		//audio
		public string audioFolderPath = "BDMk22/Sounds";
		AudioClip startLoadSound;
		AudioClip loadingSound;
		AudioClip endLoadSound;
		AudioClip shutdownSound;
		AudioSource audioSource;
		bool  hasAudio = false;

		//internal camera
		[KSPField]
		public float maxPitch = 88;
		[KSPField]
		public float minPitch = -50;
		[KSPField]
		public float maxRot = 160;

		//ship status
		float pitch = 90;
		float roll = 0;
		float horizAoA = 0;
		float vertAoA = 0;
		float heading = 0;

		[KSPField(isPersistant = true)]
		public bool ready = false;
		public bool hasInitialized = false;
		bool readyToFade = true;
		float initializeFactor = 0;

		float radarAlt = 0;
		float displayAlt = 99999;
		bool displayRdrAlt = false;

		float displaySpeed = 9999;

		Material[] hudMaterials;

		// Use this for initialization
		public void Start()
		{
			//base.OnAwake();
		
			if(!HighLogic.LoadedSceneIsFlight)
			{
				return;
			}

			if(mk22HUDs == null)
			{
				mk22HUDs = new List<Mk22HUD>();
			}

			mk22HUDs.RemoveAll(h => h == null);
			mk22HUDs.Remove(this);
			mk22HUDs.Add(this);

			part.force_activate();

			Transform ladderMeshTransform = internalProp.FindModelTransform(ladderMeshName);

			ladderUVT = new UVTransformer(ladderMeshTransform.gameObject);
			//ladderTextureSize = new Vector2(ladderUVT.texture.width, ladderUVT.texture.height);

			velRulerUVT = new UVTransformer(internalProp.FindModelTransform(velRulerMeshName).gameObject);

			altRulerUVT = new UVTransformer(internalProp.FindModelTransform(altRulerMeshName).gameObject);

			headingRulerUVT = new UVTransformer(internalProp.FindModelTransform(headingRulerMeshName).gameObject);

			velVectorObject = internalProp.FindModelTransform(velVectorObjectName).gameObject;
			velVectorOrigPos = velVectorObject.transform.localPosition;

			aslObject = internalProp.FindModelTransform(aslMeshName).gameObject;
			rdrObject = internalProp.FindModelTransform(rdrMeshName).gameObject;

			digitReference = internalProp.FindModelTransform(digitReferenceName).gameObject;
			altDigitalTransform = internalProp.FindModelTransform(altDigitalTransformName);
			spdDigitalTransform = internalProp.FindModelTransform(spdDigitalTransformName);
			altNumberField = new HUDNumberField(altDigitalTransform, 5, digitScale, digitReference, digitCharWidth, digitPixelWidth, HUDNumberField.HUDNumberAlign.Right);
			spdNumberField = new HUDNumberField(spdDigitalTransform, 4, digitScale, digitReference, digitCharWidth, digitPixelWidth, HUDNumberField.HUDNumberAlign.Right);
			digitReference.SetActive(false);

			stallObject = internalProp.FindModelTransform(stallMeshName).gameObject;
			slipObject = internalProp.FindModelTransform(slipMeshName).gameObject;

			overlayTransform = internalProp.FindModelTransform(overlayMeshName);
			logoTransform = internalProp.FindModelTransform(logoMeshName);
			subLogoTransform = internalProp.FindModelTransform(subLogoMeshName);
			loadContainerTransform = internalProp.FindModelTransform(loadContainerName);
			loadBarTransform = internalProp.FindModelTransform(loadBarName);

			logoTransform.localScale = new Vector3(1, 1, 0);
			subLogoTransform.localScale = new Vector3(1, 1, 0);
			loadContainerTransform.localScale = new Vector3(1, 1, 0);
			loadBarTransform.localScale = new Vector3(0, 1, 1);

			startLoadSound = GameDatabase.Instance.GetAudioClip(audioFolderPath + "/startLoad");
			loadingSound = GameDatabase.Instance.GetAudioClip(audioFolderPath + "/loading");
			endLoadSound = GameDatabase.Instance.GetAudioClip(audioFolderPath + "/endLoad");
			shutdownSound = GameDatabase.Instance.GetAudioClip(audioFolderPath + "/shutdown");

			if(startLoadSound && loadingSound && endLoadSound && shutdownSound)
			{
				hasAudio = true;
				audioSource = part.gameObject.AddComponent<AudioSource>();
				audioSource.minDistance = 5;
				audioSource.maxDistance = 5;
				audioSource.volume = GameSettings.SHIP_VOLUME;
				audioSource.clip = loadingSound;
				audioSource.loop = true;
				audioSource.dopplerLevel = 0;
				audioSource.Stop();
			}

			SetupHUDMaterials();


			if(ready)
			{
				//PowerOnInstantly();
			}
			else
			{
				hasInitialized = true;
				ShutDown();
			}

		}

		void OnDestroy()
		{
			if(hasAudio && audioSource)
			{
				Destroy(audioSource);
			}

			if(altNumberField != null)
			{
				altNumberField.Destroy();
			}

			if(spdNumberField != null)
			{
				spdNumberField.Destroy();
			}
		}

	

		public override void OnUpdate()
		{
			base.OnUpdate();

			if(!HighLogic.LoadedSceneIsFlight)
			{
				return;
			}

			//temporary
			/*
			if(Input.GetKeyDown(KeyCode.Keypad9))
			{
				ToggleHUD();
			}
			*/
			/*
			if(!hasInitialized)
			{
				PowerOn();
			}
			*/

			if(ready)
			{
				hasInitialized = true;

				UpdateShipStatus();
				UpdateLadderUV();
				UpdateVelocityUV(true);
				UpdateAltUV(true);
				UpdateVelVectorPos();
				UpdateHeadingUV();
			}
		}

		void Update()
		{
			UpdateCamera();
		}

		bool hasResetCamRanges = false;
		void UpdateCamera()
		{
			if(HighLogic.LoadedSceneIsFlight)
			{
				if(CameraManager.Instance && CameraManager.Instance.currentCameraMode == CameraManager.CameraMode.IVA && part.vessel.isActiveVessel)
				{
					Kerbal camKerbal = InternalCamera.Instance.transform.parent.parent.GetComponent<Kerbal>();
					if(camKerbal && camKerbal.InPart == part)
					{
						
						InternalCamera.Instance.maxPitch = maxPitch;
						InternalCamera.Instance.minPitch = minPitch;
						InternalCamera.Instance.maxRot = maxRot;
						hasResetCamRanges = false;

						float camYaw = Vector3.Angle(Vector3.ProjectOnPlane(InternalCamera.Instance.transform.forward, internalProp.transform.up), -internalProp.transform.forward);
						float sign = Mathf.Sign(Vector3.Dot(InternalCamera.Instance.transform.forward, -internalProp.transform.right));
						Vector3 lp = InternalCamera.Instance.transform.parent.localPosition;
						float normYaw = Mathf.Clamp((camYaw / 160), -1, 1);
						float worldScale = InternalCamera.Instance.transform.parent.InverseTransformVector(InternalCamera.Instance.transform.parent.right).x;
						InternalCamera.Instance.transform.parent.localPosition = new Vector3(sign * normYaw * normYaw * (0.28f * worldScale), lp.y, lp.z);
					}
					else if(!hasResetCamRanges)
					{
						ResetCamRanges();
					}
				}
				else if(!hasResetCamRanges)
				{
					ResetCamRanges();
				}
			}
		}

		void ResetCamRanges()
		{
			if(InternalCamera.Instance)
			{
				InternalCamera.Instance.maxPitch = 60;
				InternalCamera.Instance.minPitch = -30;
				InternalCamera.Instance.maxRot = 60;
				hasResetCamRanges = true;
			}
		}

		public void ToggleHUD()
		{
			if(ready)
			{
				ShutDown();
			}
			else
			{
				PowerOn();
			}
		}

		public void SetHUD(bool state)
		{
			if(state)
			{
				PowerOn();
			}
			else
			{
				ShutDown();
			}
		}
			

		public void ShutDown()
		{
			if(hasInitialized)
			{
				StopAllCoroutines();


				for(int i = 0; i < hudMaterials.Length; i++)
				{
					hudMaterials[i].SetColor("_TintColor", new Color(0, 1, 1, 0) * 0.5f);
				}

				ready = false;
				readyToFade = false;
				hasInitialized = false;

				displayAlt = 99999;
				displaySpeed = 9999;
				heading = 0;

				logoTransform.localScale = new Vector3(1, 1, 0);
				subLogoTransform.localScale = new Vector3(1, 1, 0);
				loadContainerTransform.localScale = new Vector3(1, 1, 0);
				loadBarTransform.localScale = new Vector3(0, 1, 1);

				if(hasAudio)
				{
					audioSource.pitch = 1;
					audioSource.Stop();

					if(InternalCamera.Instance && InternalCamera.Instance.isActive)
					{
						audioSource.PlayOneShot(shutdownSound);
					}
				}

				altNumberField.SetValue(-1);
				spdNumberField.SetValue(-1);


			}
		}

		public void PowerOn()
		{
			if(!hasInitialized)
			{
				hasInitialized = true;
				StartCoroutine(Initialization());
			}
		}

		public void PowerOnInstantly()
		{
			StopAllCoroutines();

			for(int i = 0; i < hudMaterials.Length; i++)
			{
				hudMaterials[i].SetColor("_TintColor", new Color(1, 1, 1, 1) * 0.5f);
			}

			ready = true;
			hasInitialized = true;
			readyToFade = true;
		}

		IEnumerator Initialization()
		{
			/*
			aslObject.SetActive(false);
			rdrObject.SetActive(false);
			stallObject.SetActive(false);
			slipObject.SetActive(false);
			velVectorObject.SetActive(false);
			*/
			StartCoroutine(HUDFadeOn());

			yield return new WaitForSeconds(0.25f);

			if(audioSource)
			{
				audioSource.PlayOneShot(startLoadSound);
			}
			StartCoroutine(LogoInitialize(logoTransform, false));

			yield return new WaitForSeconds(0.35f);

			StartCoroutine(LogoInitialize(subLogoTransform, false));

			yield return new WaitForSeconds(0.25f);

			yield return StartCoroutine(LogoInitialize(loadContainerTransform, false));

			yield return StartCoroutine(LoadBar());

			StartCoroutine(LogoInitialize(logoTransform, true));
			StartCoroutine(LogoInitialize(subLogoTransform, true));
			StartCoroutine(LogoInitialize(loadContainerTransform, true));
			StartCoroutine(LogoInitialize(loadBarTransform, true));
		}

		void SetupHUDMaterials()
		{
			if(hudMaterials == null)
			{
				hudMaterials = new Material[] {
					overlayTransform.GetComponent<MeshRenderer>().material,
					velVectorObject.GetComponent<MeshRenderer>().material,
					altRulerUVT.gameObject.GetComponent<MeshRenderer>().material,
					ladderUVT.gameObject.GetComponent<MeshRenderer>().material,
					velRulerUVT.gameObject.GetComponent<MeshRenderer>().material,
					headingRulerUVT.gameObject.GetComponent<MeshRenderer>().material,
					slipObject.GetComponent<MeshRenderer>().material,
					stallObject.GetComponent<MeshRenderer>().material,
					rdrObject.GetComponent<MeshRenderer>().material,
					aslObject.GetComponent<MeshRenderer>().material

				};
			}
		}

		IEnumerator HUDFadeOn()
		{
			while(!internalProp.isActiveAndEnabled)
			{
				yield return null;
			}

			for(int i = 0; i < hudMaterials.Length; i++)
			{
				hudMaterials[i].SetColor("_TintColor", new Color(0, 1, 1, 0) * 0.5f);
			}

			while(!readyToFade)
			{
				yield return null;
			}

			StartCoroutine(InstrumentInitializeRoutine());

			float fadeRate = 0.5f;
			float alpha = 0;
			while(alpha < 1)
			{
				alpha = Mathf.MoveTowards(alpha, 1, fadeRate * Time.deltaTime);
				for(int i = 0; i < hudMaterials.Length; i++)
				{
					hudMaterials[i].SetColor("_TintColor", new Color(1, 1, 1, alpha) * 0.5f);
				}

				UpdateShipStatus();
				UpdateLadderUV();
				UpdateVelocityUV(false);
				UpdateAltUV(false);
				UpdateVelVectorPos();
				UpdateHeadingUV();
				yield return null;
			}
				
			ready = true;
		}

		IEnumerator InstrumentInitializeRoutine()
		{
			while(initializeFactor < 1)
			{
				initializeFactor = Mathf.MoveTowards(initializeFactor, 1, 0.05f * Time.deltaTime);
				yield return null;
			}
		}

		IEnumerator LoadBar()
		{
			if(hasAudio)
			{
				audioSource.Play();
			}
			float scaleRate = 1;
			float scale = 0;
			loadBarTransform.gameObject.SetActive(true);
			loadBarTransform.localScale = new Vector3(0, 1, 1);
			while(scale < 1)
			{
				if(scale > 0.5f)
				{
					readyToFade = true;
				}
				scale = Mathf.MoveTowards(scale, 1, scaleRate * Time.deltaTime);
				loadBarTransform.localScale = new Vector3(scale, 1, 1);
				if(hasAudio)
				{
					audioSource.pitch = 1 + (scale / 2);
				}
				yield return null;
			}

			if(hasAudio)
			{
				audioSource.Stop();
				audioSource.pitch = 1;
				yield return null;
				audioSource.PlayOneShot(endLoadSound);
			}
		}
	
		IEnumerator LogoInitialize(Transform t, bool reverse)
		{
			t.gameObject.SetActive(true);
			float scaleRate = 2.5f;
			float scale = 0;
			float target = 1;
			if(reverse)
			{
				scale = 1;
				target = 0;
			}
			while(scale != target)
			{
				scale = Mathf.MoveTowards(scale, target, scaleRate * Time.deltaTime);
				t.localScale = new Vector3(1, 1, scale);
				yield return null;
			}
			if(reverse)
			{
				t.gameObject.SetActive(false);
			}
		}



		void UpdateShipStatus()
		{
			Vector3 up = (vessel.ReferenceTransform.position - vessel.mainBody.position).normalized;
			Vector3 projectedUp = Vector3.ProjectOnPlane(up, vessel.ReferenceTransform.up);
			roll = Vector3.Angle(projectedUp, -vessel.ReferenceTransform.forward);
			roll *= -Mathf.Sign(Vector3.Dot(projectedUp, vessel.ReferenceTransform.right));

			float tPitch = 90-Vector3.Angle(vessel.ReferenceTransform.up, up);
			pitch = Mathf.Lerp(pitch, tPitch, initializeFactor);

			Vector3 projectedFwd = Vector3.ProjectOnPlane(vessel.ReferenceTransform.up, up);
			Vector3 projVel = Vector3.ProjectOnPlane(vessel.srf_velocity, vessel.ReferenceTransform.forward);
			if(vessel.srfSpeed > 1)
			{
				Vector3 rightAxis = vessel.ReferenceTransform.right;// = Vector3.Cross(up, vessel.srf_velocity);
				horizAoA = Vector3.Angle(vessel.ReferenceTransform.up, projVel);
				horizAoA *= -Mathf.Sign(Vector3.Dot(rightAxis, projVel));
				//horizAoA = Mathf.Clamp(horizAoA, -horizAoALimit, horizAoALimit);

				Vector3 rProjVel = Vector3.ProjectOnPlane(vessel.srf_velocity, rightAxis);
				vertAoA = Vector3.Angle(vessel.ReferenceTransform.up, rProjVel);
				vertAoA *= Mathf.Sign(Vector3.Dot(rProjVel, -vessel.ReferenceTransform.forward));

				BlinkWarnings();
			}
			else
			{
				horizAoA = Mathf.Lerp(horizAoA, 0, 20*Time.deltaTime);
				vertAoA = Mathf.Lerp(vertAoA, 0, 20*Time.deltaTime);

				stallObject.SetActive(false);
				slipObject.SetActive(false);
			}

			Vector3 north = (vessel.mainBody.GetWorldSurfacePosition(vessel.latitude + 0.1f, vessel.longitude, vessel.altitude) - vessel.ReferenceTransform.position);
			Vector3 east = (vessel.mainBody.GetWorldSurfacePosition(vessel.latitude, vessel.longitude+0.1f, vessel.altitude) - vessel.ReferenceTransform.position);
			north = Vector3.ProjectOnPlane(north, up).normalized;
			east = Vector3.ProjectOnPlane(east, up).normalized;
			float tHeading = Vector3.Angle(north, projectedFwd);
			tHeading *= Mathf.Sign(Vector3.Dot(projectedFwd, east));
			heading = Mathf.Lerp(heading, tHeading, initializeFactor);


			radarAlt = Utils.GetRadarAltitude(vessel);

			float tAlt;
			if(radarAlt <= maxRadarAlt)
			{
				displayRdrAlt = true;
				tAlt = radarAlt;
			}
			else
			{
				displayRdrAlt = false;
				tAlt = (float)vessel.altitude;
			}
			displayAlt = Mathf.Lerp(displayAlt, tAlt, initializeFactor);

		}

		void BlinkWarnings()
		{
			if(vessel.atmDensity > 0)
			{
				if(Mathf.Abs(vertAoA) > stallAngle)
				{
					if((Mathf.RoundToInt(warningBlinkRate * Time.time)) % 2 == 0)
					{
						stallObject.SetActive(true);
					}
					else
					{
						stallObject.SetActive(false);
					}
				}
				else
				{
					stallObject.SetActive(false);
				}

				if(Mathf.Abs(horizAoA) > slipAngle)
				{
					if((Mathf.RoundToInt(warningBlinkRate * Time.time)) % 2 != 0)
					{
						slipObject.SetActive(true);
					}
					else
					{
						slipObject.SetActive(false);
					}
				}
				else
				{
					slipObject.SetActive(false);
				}
			}
			else
			{
				slipObject.SetActive(false);
				stallObject.SetActive(false);
			}
		}


		void UpdateLadderUV() 
		{
			float pitchShift = (pitch / 90) * (ladderUVT.textureSize.y/2);

			Vector2 aoa = new Vector2(horizAoA, vertAoA);
			aoa = Quaternion.AngleAxis(roll, Vector3.forward) * aoa;

			float yawShift = Mathf.Clamp(aoa.x, -horizAoALimit, horizAoALimit) * horizAoACoefficient;
			yawShift = Mathf.Clamp(yawShift, -300, 300);

			Vector2 shift = new Vector2(yawShift, pitchShift);

			ladderUVT.UpdateUVTransformation(initialLadderOffset, -roll, 0.5f*ladderUVT.textureSize, shift);
		}

		void UpdateVelocityUV(bool updateDigital)
		{
			displaySpeed = Mathf.Lerp(displaySpeed, (float)vessel.srfSpeed, initializeFactor);
			float velShift = Mathf.Clamp(displaySpeed, 0, 1650) * velRulerCoefficient;

			Vector2 shift = new Vector2(-velShift, 0);

			velRulerUVT.UpdateUVTransformation(shift, 0, Vector2.zero, Vector2.zero);

			if(updateDigital)
			{
				spdNumberField.SetValue(Mathf.RoundToInt(displaySpeed));
			}
		}

		void UpdateAltUV(bool updateDigital)
		{
			float altShift = Mathf.Clamp(displayAlt, 0, 33000) * altRulerCoefficient;

			Vector2 shift = new Vector2(-altShift, 0);

			altRulerUVT.UpdateUVTransformation(shift, 0, Vector2.zero, Vector2.zero);

			if(displayRdrAlt)
			{
				rdrObject.SetActive(true);
				aslObject.SetActive(false);
			}
			else
			{
				rdrObject.SetActive(false);
				aslObject.SetActive(true);
			}

			if(updateDigital)
			{
				altNumberField.SetValue(Mathf.RoundToInt(displayAlt));
			}
		}

		void UpdateVelVectorPos()
		{

			Vector2 aoa = new Vector2(horizAoA, vertAoA);
			aoa = Quaternion.AngleAxis(roll, Vector3.forward) * aoa;

			Vector3 vOffset = Vector3.zero;
			vOffset.z = aoa.y * velVectorVertCoefficient;
			vOffset.x = -Mathf.Clamp(aoa.x, -horizAoALimit, horizAoALimit) * velVectorHorizCoefficient;
			vOffset = Quaternion.AngleAxis(-roll, Vector3.up) * vOffset;

			if(vessel.srfSpeed > 1 && Mathf.Abs(vOffset.x) < velVectorHorizLimit && vOffset.z > velVectorBottomLimit && vOffset.z < velVectorTopLimit)
			{
				velVectorObject.SetActive(true);
				velVectorObject.transform.localPosition = velVectorOrigPos + vOffset;
			}
			else
			{
				velVectorObject.SetActive(false);
			}
		}

		void UpdateHeadingUV()
		{
			float headingShift = headingRulerUVT.textureSize.x/360 * heading;
			Vector2 shift = new Vector2(headingShift, 0);

			headingRulerUVT.UpdateUVTransformation(shift, 0, Vector2.zero, Vector2.zero);
		}





	}
}

